### Brief
- This is not goto material if you want strict standard or solid information, rather it is the collection of concept I have acquired while introducing myself to C++ by googling here & there.
- This material is also not in order. I have just collected the answer to my quick question & write it down here.
- But one thing I can assure you is that once you go through this article, you can connect many broken thought of understanding on how C++ works internally and why people call it as it runs C internally.

### What are all the default member-functions created by compiler for a class?
- Suppose you have declared class like:
```
class Thing {};
```
- Compiler will probably synthesize this class as:
```
class Thing {
public:
    Thing();                        // default constructor
    Thing(const Thing&);            // copy c'tor
    Thing& operator=(const Thing&); // copy-assign
    ~Thing();                       // d'tor
    // C++11:
    Thing(Thing&&);                 // move c'tor
    Thing& operator=(Thing&&);      // move-assign
};
```
- So by default compiler will generate:
    1. default constructor
    2. copy constructor 
    3. copy-assign operator
    4. desstructor
    5. move constructor
    6. move-assign operator

Note: This stands true till C++ 14.
- All those are only generated by the compiler when they are needed. The compiler cannot create them when they aren't used.

### How object used in executable function ?
-  Given the following function, where class X defines a copy constructor, virtual destructor, and virtual function foo():
```
X foobar()
{
    X xx;
    X *px = new X;

    // foo() is virtual function
    xx.foo();
    px->foo();
    
    delete px;
    return xx;
};

```
- Probable internal transformation would be:
```
void foobar( X &_result )
{    
    X::X(&_result);                 // _result replaces local xx & constructor called    
    px = _new( sizeof( X ));        // expand X *px = new X;
    if ( px != 0 )
        px->X::X();
        
    foo( &_result );                // expand xx.foo(): replaced xx with _result    
    ( *px->_vtbl[ 2 ] )( px )       // expand px->foo() using virtual mechanism
    
    // expand delete px;
    if ( px != 0 ) {
        ( *px->_vtbl[ 1 ] )( px ); // destructor
        _delete( px );
    }
    // replace named return statement
    // no need to destroy local object xx
    return;
};
```
- This is how object oriented paradigm converted into procedure oriented paradigm.
### How class code is transformed into sequencial code from OOPs?
- Let's take following example to understand it:
```
struct foo
{
    int m_var;

public:
    void print()
    {
        cout << m_var << endl;
    }
};
```
- Compiler treats this as :
```
struct foo
{
    int m_var;
};

void print(foo *this)
{
    std::cout.operator<<(this->m_var).operator<<(std::endl);
}
```
- As you can see above, objects & methods are a separate entity. An object only represents data members.
- All the methods in class/struct contain implicit `this` pointer as the first argument using which all non-static data members are accessed.
- Static data members are not part of class/struct. Because it usually resides in a data segment of memory layout, so it can be accessed directly.
- So this is the reason if you print the size of the above class. It will print 4 because all methods are a separate entity which operates on the object by using implicit `this` pointer.
### How & where constructor code transform/synthesize with inheritance & composition class ?

```
class Foo 
{ 
public: 
  Foo(){cout<<"Foo"<<endl;} 
  ~Foo(){cout<<"~Foo"<<endl;} 
};

class base 
{ 
public: 
  base(){cout<<"base"<<endl;}
  ~base(){cout<<"~base"<<endl;}
};

class Bar /* : public base */
{ 
  Foo foo; 
  char *str; 
public: 
  Bar()
  {
    cout<<"Bar"<<endl;
    str = 0;
  }
  ~Bar(){cout<<"~Bar"<<endl;}
};
```
- Compiler augmented `Bar` constructor would be look like:
```
Bar::Bar()
{
  foo.Foo::Foo(); // augmented compiler code
  
  cout<<"Bar"<<endl; // explicit user code
  str = 0; // explicit user code
}
```
- Same goes for, multiple class member objects requiring constructor initialization. The language specifies that the constructors would be invoked in the order of member declaration within the class. This is accomplished by the compiler.
- If an object member does not define a default constructor, a non-trivial default constructor is synthesized by a compiler for respective classes.
- In the case of inheritance, the constructor calling sequence is started from base(top-down) to derived manner. Constructor synthesis & augmentation remain same as above. So in above case if you derive `Bar` from `Base` then constructor calling sequence would be `Base` -> `Foo` -> `Bar`.

### How & where destructor code transform/synthesize with inheritance & composition class ?
- In case of the destructor, calling sequence is exactly the reverse that of a constructor. Like in above case it would be `Bar` -> `Foo` -> `Base`. Synthesis & augmentation remain same as above.

### How & where virtual table code will be inserted?
- Virtual table code will be inserted by the compiler before & after the user-written code in constructor & destructor that too on demand of user implementation.
- For the question "How virtual table code will be inserted?", my answer is "this is purely compiler dependent". C++ standard only mandates behaviour. Although this would not be complex. It probably would look like:
```
this->_vptr[0] = type_info("class_name");
```
### Reference
- https://stackoverflow.com/questions/3734247/what-are-all-the-member-functions-created-by-compiler-for-a-class-does-that-hap
- Book: Inside C++ Object Model By Lippman
